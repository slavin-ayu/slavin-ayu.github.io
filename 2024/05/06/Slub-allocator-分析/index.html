<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="本文的内核源码分析基于linux-6.8.7版本  OverviewLinux 中内核经常会有需要为各种对象分配内存的场景，但直接用 page allocator 分配的话有浪费和内存碎片的问题，于是出现了 slab allocator 来应对小内存对象的分配需求。slab allocator 基于 cache 的思想。对于内核的每个对象有其对应的 slab cache ，首先 slab all">
<meta property="og:type" content="article">
<meta property="og:title" content="Slub allocator 分析">
<meta property="og:url" content="https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Slavin&#39;s blog">
<meta property="og:description" content="本文的内核源码分析基于linux-6.8.7版本  OverviewLinux 中内核经常会有需要为各种对象分配内存的场景，但直接用 page allocator 分配的话有浪费和内存碎片的问题，于是出现了 slab allocator 来应对小内存对象的分配需求。slab allocator 基于 cache 的思想。对于内核的每个对象有其对应的 slab cache ，首先 slab all">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/object_layout1.jpg">
<meta property="og:image" content="https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/object_layout2.jpg">
<meta property="og:image" content="https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/slab_layout.jpg">
<meta property="og:image" content="https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/slab_cache_layout.jpg">
<meta property="og:image" content="https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/kmem_cache.png">
<meta property="og:image" content="https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/kmalloc.png">
<meta property="og:image" content="https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/kmalloc_cache.jpeg">
<meta property="og:image" content="https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/slab_alloc.jpg">
<meta property="og:image" content="https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/slab_free.jpg">
<meta property="article:published_time" content="2024-05-06T05:58:19.000Z">
<meta property="article:modified_time" content="2024-05-06T08:17:25.250Z">
<meta property="article:author" content="Slavin">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/object_layout1.jpg">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/android-chrome-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Slub allocator 分析</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.1.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/slavin-ayu">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/&text=Slub allocator 分析"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/&title=Slub allocator 分析"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/&is_video=false&description=Slub allocator 分析"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Slub allocator 分析&body=Check out this article: https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/&title=Slub allocator 分析"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/&title=Slub allocator 分析"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/&title=Slub allocator 分析"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/&title=Slub allocator 分析"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/&name=Slub allocator 分析&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/&t=Slub allocator 分析"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Overview"><span class="toc-number">1.</span> <span class="toc-text">Overview</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#object-slab-layout"><span class="toc-number">1.1.</span> <span class="toc-text">object &amp; slab layout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kmem-cache"><span class="toc-number">1.2.</span> <span class="toc-text">kmem_cache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-slab"><span class="toc-number">1.3.</span> <span class="toc-text">struct slab</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slab-cache-layout"><span class="toc-number">1.4.</span> <span class="toc-text">slab cache layout</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Allocate-an-object"><span class="toc-number">2.</span> <span class="toc-text">Allocate an object</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E5%B1%82-API"><span class="toc-number">2.1.</span> <span class="toc-text">上层 API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#kmem-cache-alloc-%E7%B3%BB%E5%88%97"><span class="toc-number">2.1.1.</span> <span class="toc-text">kmem_cache_alloc() 系列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kmalloc-%E7%B3%BB%E5%88%97"><span class="toc-number">2.1.2.</span> <span class="toc-text">kmalloc() 系列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slab-allocator-%E5%B1%82"><span class="toc-number">2.2.</span> <span class="toc-text">slab allocator 层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#slab-alloc-node"><span class="toc-number">2.2.1.</span> <span class="toc-text">slab_alloc_node()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#slab-alloc-node-%EF%BC%9Afastpath"><span class="toc-number">2.2.2.</span> <span class="toc-text">__slab_alloc_node()：fastpath</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#slab-alloc-%EF%BC%9Aslowpath"><span class="toc-number">2.2.3.</span> <span class="toc-text">___slab_alloc()：slowpath</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">全流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Free-an-object"><span class="toc-number">3.</span> <span class="toc-text">Free an object</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E5%B1%82-API-1"><span class="toc-number">3.1.</span> <span class="toc-text">上层 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slab-allocator-%E5%B1%82-1"><span class="toc-number">3.2.</span> <span class="toc-text">slab allocator 层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%B5%81%E7%A8%8B-1"><span class="toc-number">3.3.</span> <span class="toc-text">全流程</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        Slub allocator 分析
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Slavin</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-05-06T05:58:19.000Z" class="dt-published" itemprop="datePublished">2024-05-06</time>
        
        (Updated: <time datetime="2024-05-06T08:17:25.250Z" class="dt-updated" itemprop="dateModified">2024-05-06</time>)
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <blockquote>
<p>本文的内核源码分析基于linux-6.8.7版本</p>
</blockquote>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Linux 中内核经常会有需要为各种对象分配内存的场景，但直接用 page allocator 分配的话有浪费和内存碎片的问题，于是出现了 slab allocator 来应对小内存对象的分配需求。slab allocator 基于 cache 的思想。对于内核的每个对象有其对应的 slab cache ，首先 slab allocator 会向 buddy system 申请一个或多个连续页（看作一个复合页）作为 slab ，再将 slab 划分成若干个同样大小的小内存块，一个 slab cache 就是若干个同种 slab 的集合，此后当内核需要分配对象或者释放时，就可以直接从相应的 slab cache 的 slab 中取放 object。</p>
<p>关于 slab 对象池的三种实现：slab，slub，slob。</p>
<ul>
<li>slab：臃肿复杂</li>
<li>slub：简化高效，是默认且使用最广泛的版本</li>
<li>slob：为嵌入式小型机器小内存的场景设计</li>
</ul>
<p><strong>本文仅讨论 slub allocator，下文提到的 slab 均指 slub 实现。</strong></p>
<h3 id="object-slab-layout"><a href="#object-slab-layout" class="headerlink" title="object &amp; slab layout"></a>object &amp; slab layout</h3><p>如果配置了<code>CONFIG_SLUB_DEBUG_ON</code>又配置了<code>CONFIG_KASAN</code>的话，slab 中每个 object 的布局就是这样：  </p>
<img src="/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/object_layout1.jpg" class title="test">
<p>本文只讨论不开以上配置的情况（有缘再讨论），那么 object 的布局如下：  </p>
<img src="/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/object_layout2.jpg" class title="test">
<p>slab 里的所有空闲 object 组织成链表 freelist，free pointer（FP）指向下一个空闲 object 。FP 是内嵌在 object 里的，偏移是<code>kmem_cache-&gt;offset</code>。每个 object 需要加 padding 对齐到 word size 。  </p>
<p>slab 的布局如下：  </p>
<img src="/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/slab_layout.jpg" class title="test">

<blockquote>
<p>正常初始化时 freelist 里 object 是顺序排列，但如果配置了<code>CONFIG_SLAB_FREELIST_RANDOM</code>，就会打乱 object 的顺序</p>
</blockquote>
<h3 id="kmem-cache"><a href="#kmem-cache" class="headerlink" title="kmem_cache"></a>kmem_cache</h3><p>不同内核对象有相应的 slab cache，每个 slab cache 都由 <code>kmem_cache</code> 这个对象来表示，该对象包含管理 slab cache 的所有信息。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SLUB_TINY</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> *<span class="title">cpu_slab</span>;</span>    <span class="comment">// 会指向当前 cpu 的 kmem_cache_cpu 对象</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Used for retrieving partial slabs, etc. */</span></span><br><span class="line">    <span class="type">slab_flags_t</span> flags;                          <span class="comment">// slab 的一些属性</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> min_partial;                   <span class="comment">// kmem_cache_node-&gt;partial 上 slab 数量的一个阈值，小于这个值时 empty slab 也可以放在 kmem_cache_node-&gt;partial 里，大于这个值时就要把 empty slab 释放到 buddy system 里</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;                           <span class="comment">// object 在内存中的实际大小，除数据部分外还包括 metadata，red zone 和 padding</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> object_size;                    <span class="comment">// object 的数据部分的大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">reciprocal_value</span> <span class="title">reciprocal_size</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset;                         <span class="comment">// object 的 FP 在 object 中的偏移</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">    <span class="comment">/* Number of per cpu partial objects to keep around */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cpu_partial;					 </span><br><span class="line">    <span class="comment">/* Number of per cpu partial slabs to keep around */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cpu_partial_slabs;              <span class="comment">// kmem_cache_cpu-&gt;partial 上的 slab 的最大数目，如果超过了这个数就要把整条 partial 都移到对应 node 的 kmem_cache_node-&gt;partial 上</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span>;</span>          <span class="comment">// 低 16 位表示一个 slab 中 object 数，高 16 位为一个 slab 的 order，即这个 slab 的页数为 1 &lt;&lt; order</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocation and freeing of slabs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">min</span>;</span>         <span class="comment">// 当按照 oo 的尺寸为 slab 申请内存时，如果内存紧张，会采用 min 的尺寸为 slab 申请内存</span></span><br><span class="line">    <span class="type">gfp_t</span> allocflags;                            <span class="comment">// 向 buddy system 申请页时使用的 gfpflags</span></span><br><span class="line">    <span class="type">int</span> refcount;                                <span class="comment">// 这个 kmem_cache 对象本身的引用计数</span></span><br><span class="line">    <span class="type">void</span> (*ctor)(<span class="type">void</span> *object);                  <span class="comment">// 在 slab 初始化时调用，用于初始化其中的 object</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> inuse;                          <span class="comment">// object_size 按 word size 对齐后的长度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> align;                          <span class="comment">// object 按照指定 align 对齐</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> red_left_pad;                   <span class="comment">// 配置了 CONFIG_SLUB_DEBUG 的话 object 左右都会加上 red zone ，这是左边 red zone 的长度</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;                            <span class="comment">// 该 slab cache 的名称</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>                       <span class="comment">// 所有 kmem_cache 会组织成一个双向链表</span></span><br><span class="line">------</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED					</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> random;                        <span class="comment">// 开了 CONFIG_SLAB_FREELIST_HARDENED 的话会用这个值对 object 的 freepointer 加密</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">------</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_RANDOM						</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *random_seq;                    <span class="comment">// CONFIG_SLAB_FREELIST_RANDOM 机制相关，指向一个 map ，这个 map 用于在初始化 slab 时打乱 object 的情况下，将原 object 下标映射到打乱后的 object 在 slab 内偏移</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">------</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HARDENED_USERCOPY                  <span class="comment">// 开了 CONFIG_HARDENED_USERCOPY 后，如果某个内核对象里的内容会 copy_from_user 或者 copy_to_user 的话，那么内核在为这个对象创建 kmem_cache 时可以限定一个内核的地址范围， 以后调用 copy_from_user() 或 copy_to_user() 时会检查有没有超出这个范围</span></span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> useroffset;							</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> usersize;								</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span>  <span class="comment">// 指针数组，指向不同 node 对应的 kmem_cache_node 对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>内核各处都会用<code>kmem_cache_create()</code>首先为内核对象创建<code>kmem_cache</code>对象，管理其 slab cache ，举个例子<code>cred</code>对象的<code>kmem_cache</code>是这样创建的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/kernel/cred.c:606</span></span><br><span class="line"><span class="comment">/* 606 */</span> <span class="type">void</span> __init <span class="title function_">cred_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"><span class="comment">/* 607 */</span> &#123;</span><br><span class="line"><span class="comment">/* 608 */</span>     <span class="comment">/* allocate a slab in which we can store credentials */</span></span><br><span class="line"><span class="comment">/* 609 */</span>     cred_jar = kmem_cache_create(<span class="string">&quot;cred_jar&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> cred), <span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 610 */</span>     SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/* 611 */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以用<code>kmem_cache_alloc()</code>从这个 slab cache 中申请 object 了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/kernel/cred.c:206</span></span><br><span class="line"><span class="comment">/* 206 */</span> <span class="keyword">struct</span> cred *<span class="title function_">prepare_creds</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"><span class="comment">/* 207 */</span> &#123;</span><br><span class="line"><span class="comment">/* 208 */</span>     <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =</span> current;</span><br><span class="line"><span class="comment">/* 209 */</span>     <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line"><span class="comment">/* 210 */</span>     <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"><span class="comment">/* 211 */</span> </span><br><span class="line"><span class="comment">/* 212 */</span>     new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br></pre></td></tr></table></figure>
<h3 id="struct-slab"><a href="#struct-slab" class="headerlink" title="struct slab"></a>struct slab</h3><p>就像 struct page 对象管理一张 page 一样，一张 slab 由 struct slab 对象管理，因为 slab 本质是单页或复合页，所以 struct slab 复用 struct folio 以及 struct page</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> __page_flags;                   <span class="comment">// slab 所处页的相关属性</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span>                <span class="comment">// 指向 slab 所属的 slab cache 的 kmem_cache 对象</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span>       <span class="comment">// slab 在 kmem_cache_node 上以双向链表组织（partial list 或是 full list）</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">next</span>;</span>            <span class="comment">// slab 在 kmem_cache_cpu-&gt;partial 上以单向链表组织</span></span><br><span class="line">                    <span class="type">int</span> slabs;                    <span class="comment">// slab 在 kmem_cache_cpu-&gt;partial 上时后面 slab 的数量（包括自己）</span></span><br><span class="line">                &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">/* Double-word boundary */</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                    <span class="type">void</span> *freelist;               <span class="comment">// 指向 slab 内第一个空闲 object</span></span><br><span class="line">                    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                        <span class="type">unsigned</span> <span class="type">long</span> counters;   <span class="comment">// 注意对 counters 赋值操作就是同时对 inuse objects frozen 赋值</span></span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                            <span class="type">unsigned</span> inuse:<span class="number">16</span>;    <span class="comment">// slab 中已分配的 object 数量</span></span><br><span class="line">                            <span class="type">unsigned</span> objects:<span class="number">15</span>;  <span class="comment">// slab 中 object 总数</span></span><br><span class="line">                            <span class="type">unsigned</span> frozen:<span class="number">1</span>;    <span class="comment">// slab 是否是某个 cpu 的 kmem_cache_cpu-&gt;slab</span></span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> system_has_freelist_aba</span></span><br><span class="line">                <span class="type">freelist_aba_t</span> freelist_counter;  <span class="comment">// 用于 cmpxchg128 时同时操作 freelist 和 counters</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> __unused;</span><br><span class="line"></span><br><span class="line">    <span class="type">atomic_t</span> __page_refcount;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> memcg_data;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="slab-cache-layout"><a href="#slab-cache-layout" class="headerlink" title="slab cache layout"></a>slab cache layout</h3><p>slab cache 的这些 slabs 是如何组织的？接下来看 slab cache 的布局：</p>
<img src="/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/slab_cache_layout.jpg" class title="test">

<p>slab cache 在每个 cpu 上有个本地缓存，这个本地缓存用 <code>kmem_cache_cpu</code> 对象表示，可以通过 <code>kmem_cache</code> 的 percpu 变量成员 <code>cpu_slab</code> 找到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">void</span> **freelist;         <span class="comment">// 指向 kmem_cache_cpu-&gt;slab 上的空闲 object</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> tid;       <span class="comment">// 全局标识</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">freelist_aba_t</span> freelist_tid;		</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span>               <span class="comment">// 指向当前缓存的 slab</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">partial</span>;</span>            <span class="comment">// 备用 slab 列表</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">local_lock_t</span> lock;	<span class="comment">/* Protects the fields above */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_STATS</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> stat[NR_SLUB_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>kmem_cache_cpu</code> 缓存了一张 slab 和一个备用 slab 列表（需要配置<code>CONFIG_SLUB_CPU_PARTIAL</code>）。 </p>
<blockquote>
<p>从 slab cache 的布局图中可以看出<code>kmem_cache_cpu-&gt;freelist</code>和<code>kmem_cache_cpu-&gt;slab-&gt;freelist</code>都指向<code>kmem_cache_cpu-&gt;slab</code>上的空闲 object，但是它们是两个不同的 freelist，前者是无锁 freelist ，后者是常规 freelist ，在对象分配一章会进一步讨论。</p>
</blockquote>
<p>当进程需要分配对象时，首先找到当前 cpu 的<code>kmem_cache_cpu</code>对象</p>
<ul>
<li>一开始尝试到<code>kmem_cache_cpu-&gt;freelist</code>取 object ，这个过程无锁且不用禁用中断和抢占</li>
<li>如果<code>kmem_cache_cpu-&gt;freelist</code>没有空闲 object ，会到<code>kmem_cache_cpu-&gt;slab-&gt;freelist</code>取 object </li>
<li>如果以上两步都失败，说明本地缓存的 slab 没有空闲 object 了，就将<code>kmem_cache_cpu-&gt;partial</code>上第一张 slab 提升为<code>kmem_cache_cpu-&gt;slab</code>，将其 freelist 移交给<code>kmem_cache_cpu-&gt;freelist</code>（<code>slab-&gt;freelist</code>置 0 ）</li>
</ul>
<p>如果 slab cache 的 per-cpu 本地缓存没有空闲 object 了，就要从本地 node 的后备内存池补充一些 slab，这个 per-node 的内存池由<code>kmem_cache_node</code>对象管理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> &#123;</span></span><br><span class="line">    <span class="type">spinlock_t</span> list_lock;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nr_partial;    <span class="comment">// partial list 上的 slab 数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">partial</span>;</span>    <span class="comment">// partial list</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">    <span class="type">atomic_long_t</span> nr_slabs;</span><br><span class="line">    <span class="type">atomic_long_t</span> total_objects;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">full</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>和<code>kmem_cache_cpu</code>一样有一个 partial list 缓存了一些 slab，当尝试从 cpu 本地缓存分配失败时就会从本地 node 的<code>kmem_cache_node-&gt;partial</code>上取一张 slab 提升为<code>kmem_cache_cpu-&gt;slab</code>并且移一些 slab 到<code>kmem_cache_cpu-&gt;partial</code>上</p>
<blockquote>
<p>除非配置了<code>CONFIG_SLUB_DEBUG</code>否则没必要去维护一个 full list ，因为当一个 full slab 中的 object 被释放时，我们可以由 object 地址找到这个 slab 并且得知这个 slab 由 full 变成 partial，就可以将这个 slab 放入正确的 partial list 中</p>
</blockquote>
<blockquote>
<p>虽然 <code>kmem_cache_cpu</code>和<code>kmem_cache_node</code>的 slab 池都叫 “ partial list ” 但其实上面的 slab 可以是半空的也可以是全空的</p>
</blockquote>
<h2 id="Allocate-an-object"><a href="#Allocate-an-object" class="headerlink" title="Allocate an object"></a>Allocate an object</h2><h3 id="上层-API"><a href="#上层-API" class="headerlink" title="上层 API"></a>上层 API</h3><p>内核会为核心对象创建专属 slab cache ，例如:</p>
<img src="/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/kmem_cache.png" class title="test">
<p>每个不同的 slab cache 分别由<code>kmem_cache</code>对象管理，当内核需要分配对象时就会从其专属的 slab cache 中取  </p>
<p>除了专属 slab cache 以外，内核还准备了尺寸从 8 到 8K 字节的通用 slab cache：</p>
<img src="/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/kmalloc.png" class title="test">
<p>这是因为内核还经常有分配通用内存块的需求，就会从合适尺寸的通用 slab cache 中取</p>
<h4 id="kmem-cache-alloc-系列"><a href="#kmem-cache-alloc-系列" class="headerlink" title="kmem_cache_alloc() 系列"></a><em>kmem_cache_alloc()</em> 系列</h4><p>从专属 slab cache 中分配的 API 是<code>kmem_cache_alloc()</code>：</p>
<blockquote>
<p>参数<code>s</code>指定从哪个 slab cache 中分配，参数<code>gfpflags</code>是内存分配标志位（<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/core-api/mm-api.html#mm-api-gfp-flags" title="gfpflags">具体见</a>）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/mm/slub.c:3865</span></span><br><span class="line"><span class="comment">/* 3865 */</span> <span class="type">void</span> *<span class="title function_">kmem_cache_alloc</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> gfpflags)</span></span><br><span class="line"><span class="comment">/* 3866 */</span> &#123;</span><br><span class="line"><span class="comment">/* 3867 */</span>     <span class="type">void</span> *ret = slab_alloc_node(s, <span class="literal">NULL</span>, gfpflags, NUMA_NO_NODE, _RET_IP_,</span><br><span class="line"><span class="comment">/* 3868 */</span>                     s-&gt;object_size);</span><br><span class="line"><span class="comment">/* 3869 */</span> </span><br><span class="line"><span class="comment">/* 3870 */</span>     trace_kmem_cache_alloc(_RET_IP_, ret, s, gfpflags, NUMA_NO_NODE);</span><br><span class="line"><span class="comment">/* 3871 */</span> </span><br><span class="line"><span class="comment">/* 3872 */</span>     <span class="keyword">return</span> ret;</span><br><span class="line"><span class="comment">/* 3873 */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>如果还要指定从哪个 node 上分配，就用<code>kmem_cache_alloc_node()</code></p>
<h4 id="kmalloc-系列"><a href="#kmalloc-系列" class="headerlink" title="kmalloc() 系列"></a><em>kmalloc()</em> 系列</h4><p><code>kmalloc()</code>系列函数用来从通用 slab cache 中分配内存，这块内存可以用于存储任何信息。</p>
<p>先看<code>kmalloc()</code>：</p>
<blockquote>
<p>参数<code>size</code>指定分配的大小，参数<code>gfpflags</code>是内存分配标志位</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/include/linux/slab.h:581</span></span><br><span class="line"><span class="comment">/* 581 */</span> <span class="type">static</span> __always_inline __alloc_size(<span class="number">1</span>) <span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span></span><br><span class="line"><span class="comment">/* 582 */</span> &#123;</span><br><span class="line"><span class="comment">/* 583 */</span>     <span class="keyword">if</span> (__builtin_constant_p(size) &amp;&amp; size) &#123;</span><br><span class="line"><span class="comment">/* 584 */</span>         <span class="type">unsigned</span> <span class="type">int</span> index;</span><br><span class="line"><span class="comment">/* 585 */</span> </span><br><span class="line"><span class="comment">/* 586 */</span>         <span class="keyword">if</span> (size &gt; KMALLOC_MAX_CACHE_SIZE)</span><br><span class="line"><span class="comment">/* 587 */</span>             <span class="keyword">return</span> kmalloc_large(size, flags);</span><br><span class="line"><span class="comment">/* 588 */</span> </span><br><span class="line"><span class="comment">/* 589 */</span>         index = kmalloc_index(size);</span><br><span class="line"><span class="comment">/* 590 */</span>         <span class="keyword">return</span> kmalloc_trace(</span><br><span class="line"><span class="comment">/* 591 */</span>                 kmalloc_caches[kmalloc_type(flags, _RET_IP_)][index],</span><br><span class="line"><span class="comment">/* 592 */</span>                 flags, size);</span><br><span class="line"><span class="comment">/* 593 */</span>     &#125;</span><br><span class="line"><span class="comment">/* 594 */</span>     <span class="keyword">return</span> __kmalloc(size, flags);</span><br><span class="line"><span class="comment">/* 595 */</span> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/mm/slub.c:3992</span></span><br><span class="line"><span class="comment">/* 3992 */</span> <span class="type">void</span> *__kmalloc(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span><br><span class="line"><span class="comment">/* 3993 */</span> &#123;</span><br><span class="line"><span class="comment">/* 3994 */</span>     <span class="keyword">return</span> __do_kmalloc_node(size, flags, NUMA_NO_NODE, _RET_IP_);</span><br><span class="line"><span class="comment">/* 3995 */</span> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/mm/slub.c:3961</span></span><br><span class="line"><span class="comment">/* 3961 */</span> <span class="type">static</span> __always_inline</span><br><span class="line"><span class="comment">/* 3962 */</span> <span class="type">void</span> *__do_kmalloc_node(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags, <span class="type">int</span> node,</span><br><span class="line"><span class="comment">/* 3963 */</span>             <span class="type">unsigned</span> <span class="type">long</span> caller)</span><br><span class="line"><span class="comment">/* 3964 */</span> &#123;</span><br><span class="line"><span class="comment">/* 3965 */</span>     <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span>;</span></span><br><span class="line"><span class="comment">/* 3966 */</span>     <span class="type">void</span> *ret;</span><br><span class="line"><span class="comment">/* 3967 */</span> </span><br><span class="line"><span class="comment">/* 3968 */</span>     <span class="keyword">if</span> (unlikely(size &gt; KMALLOC_MAX_CACHE_SIZE)) &#123;</span><br><span class="line"><span class="comment">/* 3969 */</span>         ret = __kmalloc_large_node(size, flags, node);</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3972 */</span>         <span class="keyword">return</span> ret;</span><br><span class="line"><span class="comment">/* 3973 */</span>     &#125;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3978 */</span>     s = kmalloc_slab(size, flags, caller);</span><br><span class="line"><span class="comment">/* 3979 */</span> </span><br><span class="line"><span class="comment">/* 3980 */</span>     ret = slab_alloc_node(s, <span class="literal">NULL</span>, flags, node, caller, size);</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3983 */</span>     <span class="keyword">return</span> ret;</span><br><span class="line"><span class="comment">/* 3984 */</span> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/mm/slub.c:4005</span></span><br><span class="line"><span class="comment">/* 4005 */</span> <span class="type">void</span> *<span class="title function_">kmalloc_trace</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> gfpflags, <span class="type">size_t</span> size)</span></span><br><span class="line"><span class="comment">/* 4006 */</span> &#123;</span><br><span class="line"><span class="comment">/* 4007 */</span>     <span class="type">void</span> *ret = slab_alloc_node(s, <span class="literal">NULL</span>, gfpflags, NUMA_NO_NODE,</span><br><span class="line"><span class="comment">/* 4008 */</span>                         _RET_IP_, size);</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 4013 */</span>     <span class="keyword">return</span> ret;</span><br><span class="line"><span class="comment">/* 4014 */</span> &#125;</span><br></pre></td></tr></table></figure>
<p><code>kmalloc()</code>和<code>kmem_cache_alloc()</code>一样最后都会调用到<code>slab_alloc_node()</code>使用底层 slab allocator ，但在那之前<code>kmalloc()</code>的首要任务是通过参数<code>size</code>和<code>gfpflags</code>来确定到底应该从哪个 slab cache 中分配  </p>
<p><code>kmalloc()</code>的内存池有以下 slab cache：</p>
<img src="/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/kmalloc_cache.jpeg" class title="test">

<p><code>kmalloc()</code>根据<code>gfpflags</code>判断 slab cache 类型：（如果同时指定了多个 flag 就按以下优先级顺序）</p>
<ul>
<li>dma-kmalloc-* ：内存来自<code>ZONE_DMA</code>区域，指定 flag 为<code>GFP_DMA</code></li>
<li>kmalloc-rcl-* ：可以被回收的内存，指定 flag 为<code>__GFP_RECLAIMABLE</code></li>
<li>kmalloc-cg-* ：需要统计（ memcg 相关）的内存，指定 flag 为<code>GFP_KERNEL_ACCOUNT</code></li>
<li>kmalloc-* ：通用类型，如果没有指定以上 flag 就用这个</li>
</ul>
<p>再根据<code>size</code>计算找到合适尺寸的 slab cache 的<code>kmem_cache</code>对象，然后调用<code>slab_alloc_node()</code></p>
<blockquote>
<p>但如果<code>size</code>大于 8K 字节的话就不会走 slab allocator 而是会调用<code>__kmalloc_large_node()</code>直接用 page allocator 向 buddy system 请求连续的页<br><code>kmalloc()</code>里根据<code>size</code>是否是编译时常量选择了两种计算<code>kmem_cache</code>的方式，其中一个方式是编译时优化的，所以看起来绕了个弯</p>
</blockquote>
<p><br><code>kmalloc()</code>系列还有：</p>
<ul>
<li><code>kzalloc()</code>：和<code>kmalloc()</code>一样但会将内存初始化为 0</li>
<li><code>kmalloc_array()</code>：用<code>kmalloc()</code>分配大小为<code>n * size</code>的内存</li>
<li><code>kcalloc()</code>：和<code>kmalloc_array()</code>一样但会将内存初始化为 0</li>
<li><code>*_node()</code>：指定从哪个 node 上分配，比如<code>kmalloc_node()</code>，以上那些没指定 node 的 API 都默认从最近的 node 上分配，如果分配失败的话就会到其他 node 上尝试，但是如果一开始指定了 node 的话就不会到其他 node 上尝试</li>
</ul>
<h3 id="slab-allocator-层"><a href="#slab-allocator-层" class="headerlink" title="slab allocator 层"></a>slab allocator 层</h3><h4 id="slab-alloc-node"><a href="#slab-alloc-node" class="headerlink" title="slab_alloc_node()"></a>slab_alloc_node()</h4><p>以上的 API 都会调用到<code>slab_alloc_node()</code>即 slab allocator 的接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/mm/slub.c:3835</span></span><br><span class="line"><span class="comment">/* 3835 */</span> <span class="type">static</span> __fastpath_inline <span class="type">void</span> *<span class="title function_">slab_alloc_node</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> list_lru *lru,</span></span><br><span class="line"><span class="params"><span class="comment">/* 3836 */</span> 		   <span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node, <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">size_t</span> orig_size)</span></span><br><span class="line"><span class="comment">/* 3837 */</span> &#123;</span><br><span class="line"><span class="comment">/* 3838 */</span>     <span class="type">void</span> *object;</span><br><span class="line"><span class="comment">/* 3839 */</span>     <span class="class"><span class="keyword">struct</span> <span class="title">obj_cgroup</span> *<span class="title">objcg</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* 3840 */</span>     <span class="type">bool</span> init = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/* 3841 */</span>	   </span><br><span class="line"><span class="comment">/* 3842 */</span>     s = slab_pre_alloc_hook(s, lru, &amp;objcg, <span class="number">1</span>, gfpflags);</span><br><span class="line"><span class="comment">/* 3843 */</span>     <span class="keyword">if</span> (unlikely(!s))</span><br><span class="line"><span class="comment">/* 3844 */</span>         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* 3845 */</span></span><br><span class="line"><span class="comment">/* 3846 */</span>     object = kfence_alloc(s, orig_size, gfpflags);</span><br><span class="line"><span class="comment">/* 3847 */</span>     <span class="keyword">if</span> (unlikely(object))</span><br><span class="line"><span class="comment">/* 3848 */</span>         <span class="keyword">goto</span> out;</span><br><span class="line"><span class="comment">/* 3849 */</span></span><br><span class="line"><span class="comment">/* 3850 */</span>     object = __slab_alloc_node(s, gfpflags, node, addr, orig_size);</span><br><span class="line"><span class="comment">/* 3851 */</span> </span><br><span class="line"><span class="comment">/* 3852 */</span>     maybe_wipe_obj_freeptr(s, object);</span><br><span class="line"><span class="comment">/* 3853 */</span>     init = slab_want_init_on_alloc(gfpflags, s);</span><br><span class="line"><span class="comment">/* 3854 */</span></span><br><span class="line"><span class="comment">/* 3855 */</span> out:</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3860 */</span>     slab_post_alloc_hook(s, objcg, gfpflags, <span class="number">1</span>, &amp;object, init, orig_size);</span><br><span class="line"><span class="comment">/* 3861 */</span></span><br><span class="line"><span class="comment">/* 3862 */</span>     <span class="keyword">return</span> object;</span><br><span class="line"><span class="comment">/* 3863 */</span> &#125;</span><br></pre></td></tr></table></figure>
<p><code>slab_alloc_node()</code>是<code>__slab_alloc_node()</code>的 wrapper，还包含前后处理：</p>
<blockquote>
<ul>
<li><code>slab_pre_alloc_hook()</code>内会处理 memcg 相关  </li>
<li>3846 - 3848 行用于 kfence 机制采样  </li>
<li>在<code>maybe_wipe_obj_freeptr()</code>里在一定条件下会把分配下来的 object 的 FP 置 0  </li>
<li>如果<code>gfpflags</code>还有<code>__GFP_ZERO</code>，则<code>slab_post_alloc_hook()</code>会把 object 初始化为 0 ，此外还有 KASan ，KMSan ，kmemleak 相关以及 memcg 的后处理</li>
</ul>
</blockquote>
<h4 id="slab-alloc-node-：fastpath"><a href="#slab-alloc-node-：fastpath" class="headerlink" title="__slab_alloc_node()：fastpath"></a>__slab_alloc_node()：fastpath</h4><p><code>__slab_alloc_node()</code>首先尝试从当前 cpu 的本地缓存的无锁 freelist ，即<code>kmem_cache_cpu-&gt;freelist</code>上分配 object ，这个过程无锁且不禁用抢占和中断，是开销最小的路径，称为 fastpath</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/mm/slub.c:3632</span></span><br><span class="line"><span class="comment">/* 3632 */</span> <span class="type">static</span> __always_inline <span class="type">void</span> *__slab_alloc_node(<span class="keyword">struct</span> kmem_cache *s,</span><br><span class="line"><span class="comment">/* 3633 */</span>         <span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node, <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">size_t</span> orig_size)</span><br><span class="line"><span class="comment">/* 3634 */</span> &#123;</span><br><span class="line"><span class="comment">/* 3635 */</span>     <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span>;</span></span><br><span class="line"><span class="comment">/* 3636 */</span>     <span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line"><span class="comment">/* 3637 */</span>     <span class="type">unsigned</span> <span class="type">long</span> tid;</span><br><span class="line"><span class="comment">/* 3638 */</span>     <span class="type">void</span> *object;</span><br><span class="line"><span class="comment">/* 3639 */</span> </span><br><span class="line"><span class="comment">/* 3640 */</span> redo:</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3653 */</span>     c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line"><span class="comment">/* 3654 */</span>     tid = READ_ONCE(c-&gt;tid);</span><br><span class="line">------ </span><br><span class="line"><span class="comment">/* 3664 */</span>     barrier();</span><br><span class="line">------ </span><br><span class="line"><span class="comment">/* 3673 */</span>     object = c-&gt;freelist;</span><br><span class="line"><span class="comment">/* 3674 */</span>     slab = c-&gt;slab;</span><br><span class="line"><span class="comment">/* 3675 */</span> </span><br><span class="line"><span class="comment">/* 3676 */</span>     <span class="keyword">if</span> (!USE_LOCKLESS_FAST_PATH() ||</span><br><span class="line"><span class="comment">/* 3677 */</span>         unlikely(!object || !slab || !node_match(slab, node))) &#123;</span><br><span class="line"><span class="comment">/* 3678 */</span>         object = __slab_alloc(s, gfpflags, node, addr, c, orig_size);</span><br><span class="line"><span class="comment">/* 3679 */</span>     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* 3680 */</span>         <span class="type">void</span> *next_object = get_freepointer_safe(s, object);</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3696 */</span> 	       <span class="keyword">if</span> (unlikely(!__update_cpu_freelist_fast(s, object, next_object, tid))) &#123;</span><br><span class="line"><span class="comment">/* 3697 */</span>             note_cmpxchg_failure(<span class="string">&quot;slab_alloc&quot;</span>, s, tid);</span><br><span class="line"><span class="comment">/* 3698 */</span>             <span class="keyword">goto</span> redo;</span><br><span class="line"><span class="comment">/* 3699 */</span>         &#125;</span><br><span class="line"><span class="comment">/* 3700 */</span>         prefetch_freepointer(s, next_object);</span><br><span class="line"><span class="comment">/* 3701 */</span>         stat(s, ALLOC_FASTPATH);</span><br><span class="line"><span class="comment">/* 3702 */</span>     &#125;</span><br><span class="line"><span class="comment">/* 3703 */</span> </span><br><span class="line"><span class="comment">/* 3704 */</span>     <span class="keyword">return</span> object;</span><br><span class="line"><span class="comment">/* 3705 */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>kmem_cache_cpu-&gt;freelist</code>上有 object 就取出来返回<br>第 3696 行的<code>__update_cpu_freelist_fast()</code>用<code>cmpxchg128</code>原子地做了以下事情：</p>
<ol>
<li>将当前 cpu 的<code>kmem_cache_cpu-&gt;tid</code>与之前读取的<code>tid</code>比较</li>
<li>如果前后<code>tid</code>一致就更新<code>kmem_cache_cpu-&gt;freelist = next_object</code>以及<code>kmem_cache_cpu-&gt;tid = tid + 1</code>，否则说明发生过抢占：当前进程被调度到其他 cpu 上了，需要回到<code>redo</code>用当前 cpu 的本地缓存重新分配</li>
</ol>
<h4 id="slab-alloc-：slowpath"><a href="#slab-alloc-：slowpath" class="headerlink" title="___slab_alloc()：slowpath"></a>___slab_alloc()：slowpath</h4><p>如果<code>kmem_cache_cpu</code>的 slab 或 freelist 为空或者分配的时候指定了 node 而 slab 不在这个 node 上，就会进入 slowpath，首先<code>__slab_alloc()</code>会禁抢占和中断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/mm/slub.c:3611</span></span><br><span class="line"><span class="comment">/* 3611 */</span> <span class="type">static</span> <span class="type">void</span> *__slab_alloc(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node,</span><br><span class="line"><span class="comment">/* 3612 */</span>             <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="keyword">struct</span> kmem_cache_cpu *c, <span class="type">unsigned</span> <span class="type">int</span> orig_size)</span><br><span class="line"><span class="comment">/* 3613 */</span> &#123;</span><br><span class="line"><span class="comment">/* 3614 */</span>     <span class="type">void</span> *p;</span><br><span class="line"><span class="comment">/* 3615 */</span> </span><br><span class="line"><span class="comment">/* 3616 */</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_PREEMPT_COUNT</span></span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3622 */</span>     c = slub_get_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line"><span class="comment">/* 3623 */</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* 3624 */</span> </span><br><span class="line"><span class="comment">/* 3625 */</span>     p = ___slab_alloc(s, gfpflags, node, addr, c, orig_size);</span><br><span class="line"><span class="comment">/* 3626 */</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_PREEMPT_COUNT</span></span><br><span class="line"><span class="comment">/* 3627 */</span>     slub_put_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line"><span class="comment">/* 3628 */</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* 3629 */</span>     <span class="keyword">return</span> p;</span><br><span class="line"><span class="comment">/* 3630 */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>然后进入<code>___slab_alloc()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/mm/slub.c:3388</span></span><br><span class="line"><span class="comment">/* 3388 */</span> <span class="type">static</span> <span class="type">void</span> *___slab_alloc(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node,</span><br><span class="line"><span class="comment">/* 3389 */</span>                <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="keyword">struct</span> kmem_cache_cpu *c, <span class="type">unsigned</span> <span class="type">int</span> orig_size)</span><br><span class="line"><span class="comment">/* 3390 */</span> &#123;</span><br><span class="line"><span class="comment">/* 3391 */</span>     <span class="type">void</span> *freelist;</span><br><span class="line"><span class="comment">/* 3392 */</span>     <span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line"><span class="comment">/* 3393 */</span>     <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="comment">/* 3394 */</span>     <span class="class"><span class="keyword">struct</span> <span class="title">partial_context</span> <span class="title">pc</span>;</span></span><br></pre></td></tr></table></figure>
<p>首先在<code>reread_slab</code>处读<code>kmem_cache_cpu-&gt;slab</code>，然后：</p>
<ul>
<li>如果<code>kmem_cache_cpu</code>没有 slab ，需要跳转到<code>new_slab</code>处缓存一张新的 slab</li>
<li>如果该 slab 的 node 不是指定的 node 或者该 slab 属于<code>pfmemalloc</code>池而<code>gfpflags</code>表明不允许从该区域分配内存，则需要跳转到<code>deactivate_slab</code>处把这张 slab 从<code>kmem_cache_cpu</code>上取下来</li>
<li>检查一下前面读取的 slab 是否还是<code>kmem_cache_cpu-&gt;slab</code>，如果不是说明发生过抢占并且<code>kmem_cache_cpu-&gt;slab</code>被修改了，需要回到<code>reread_slab</code>重来</li>
<li>先看<code>kmem_cache_cpu-&gt;freelist</code>，如果不为空那么跳转到<code>load_freelist</code>处把 object 取出</li>
<li>再看<code>kmem_cache_cpu-&gt;slab-&gt;freelist</code>，如果不为空就移交给<code>kmem_cache_cpu-&gt;freelist</code>，然后往下走到<code>load_freelist</code>处把 object 取出，否则说明<code>kmem_cache_cpu-&gt;slab</code>没空闲 object 了，解冻（置 slab-&gt;frozen 为 0 ，意味着这张 slab 被移出本地缓存<code>kmem_cache_cpu</code>了）并到<code>new_slab</code>处缓存一张新的 slab<blockquote>
<p><code>kmem_cache_cpu</code>上有两个 freelist ，但它们在同一个 slab 也就是<code>kmem_cache_cpu-&gt;slab</code>上。区别在于<code>kmem_cache_cpu-&gt;freelist</code>是无锁 freelist，也就是用于 fastpath 分配的 freelist。当一个 slab 成为<code>kmem_cache_cpu-&gt;slab</code>时，其 freelist 会被移交给<code>kmem_cache_cpu-&gt;freelist</code>，而原 freelist 会被置 0 ，此后当这张 slab 上的 object 被其他 cpu 释放时会进入<code>slab-&gt;freelist</code>，于是就形成了两个 freelist。slowpath 中如果<code>kmem_cache_cpu-&gt;freelist</code>为空但<code>kmem_cache_cpu-&gt;slab-&gt;freelist</code>不为空，还要将后者移交给前者。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/mm/slub.c:3398</span></span><br><span class="line"><span class="comment">/* 3398 */</span> reread_slab:</span><br><span class="line"><span class="comment">/* 3399 */</span> </span><br><span class="line"><span class="comment">/* 3400 */</span>     slab = READ_ONCE(c-&gt;slab);</span><br><span class="line"><span class="comment">/* 3401 */</span>     <span class="keyword">if</span> (!slab) &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3406 */</span>         <span class="keyword">if</span> (unlikely(node != NUMA_NO_NODE &amp;&amp;</span><br><span class="line"><span class="comment">/* 3407 */</span>                 !node_isset(node, slab_nodes)))</span><br><span class="line"><span class="comment">/* 3408 */</span>             node = NUMA_NO_NODE;</span><br><span class="line"><span class="comment">/* 3409 */</span>         <span class="keyword">goto</span> new_slab;</span><br><span class="line"><span class="comment">/* 3410 */</span>     &#125;</span><br><span class="line"><span class="comment">/* 3411 */</span> </span><br><span class="line"><span class="comment">/* 3412 */</span>     <span class="keyword">if</span> (unlikely(!node_match(slab, node))) &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3417 */</span>         <span class="keyword">if</span> (!node_isset(node, slab_nodes)) &#123;</span><br><span class="line"><span class="comment">/* 3418 */</span>             node = NUMA_NO_NODE;</span><br><span class="line"><span class="comment">/* 3419 */</span>         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* 3420 */</span>             stat(s, ALLOC_NODE_MISMATCH);</span><br><span class="line"><span class="comment">/* 3421 */</span>             <span class="keyword">goto</span> deactivate_slab;</span><br><span class="line"><span class="comment">/* 3422 */</span>         &#125;</span><br><span class="line"><span class="comment">/* 3423 */</span>     &#125;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3430 */</span>     <span class="keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags)))</span><br><span class="line"><span class="comment">/* 3431 */</span>         <span class="keyword">goto</span> deactivate_slab;</span><br><span class="line"><span class="comment">/* 3432 */</span> </span><br><span class="line"><span class="comment">/* 3433 */</span> 	<span class="comment">/* must check again c-&gt;slab in case we got preempted and it changed */</span></span><br><span class="line"><span class="comment">/* 3434 */</span>     local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="comment">/* 3435 */</span>     <span class="keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;</span><br><span class="line"><span class="comment">/* 3436 */</span>         local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="comment">/* 3437 */</span>         <span class="keyword">goto</span> reread_slab;</span><br><span class="line"><span class="comment">/* 3438 */</span>     &#125;</span><br><span class="line"><span class="comment">/* 3439 */</span>     freelist = c-&gt;freelist;</span><br><span class="line"><span class="comment">/* 3440 */</span>     <span class="keyword">if</span> (freelist)</span><br><span class="line"><span class="comment">/* 3441 */</span>         <span class="keyword">goto</span> load_freelist;</span><br><span class="line"><span class="comment">/* 3442 */</span> </span><br><span class="line"><span class="comment">/* 3443 */</span>     freelist = get_freelist(s, slab);</span><br><span class="line"><span class="comment">/* 3444 */</span> </span><br><span class="line"><span class="comment">/* 3445 */</span>     <span class="keyword">if</span> (!freelist) &#123;</span><br><span class="line"><span class="comment">/* 3446 */</span>         c-&gt;slab = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* 3447 */</span>         c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line"><span class="comment">/* 3448 */</span>         local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="comment">/* 3449 */</span>         stat(s, DEACTIVATE_BYPASS);</span><br><span class="line"><span class="comment">/* 3450 */</span>         <span class="keyword">goto</span> new_slab;</span><br><span class="line"><span class="comment">/* 3451 */</span>     &#125;</span><br><span class="line"><span class="comment">/* 3452 */</span> </span><br><span class="line"><span class="comment">/* 3453 */</span>     stat(s, ALLOC_REFILL);</span><br><span class="line"><span class="comment">/* 3454 */</span> </span><br></pre></td></tr></table></figure>
如果来到<code>load_freelist</code>，说明分配成功，返回空闲 object ，更新<code>kmem_cache_cpu-&gt;freelist</code>（指向下一个空闲 object ）和<code>kmem_cache_cpu-&gt;tid</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/mm/slub.c:3455</span></span><br><span class="line"><span class="comment">/* 3455 */</span> load_freelist:</span><br><span class="line"><span class="comment">/* 3456 */</span> </span><br><span class="line"><span class="comment">/* 3457 */</span>     lockdep_assert_held(this_cpu_ptr(&amp;s-&gt;cpu_slab-&gt;lock));</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3464 */</span>     VM_BUG_ON(!c-&gt;slab-&gt;frozen);</span><br><span class="line"><span class="comment">/* 3465 */</span>     c-&gt;freelist = get_freepointer(s, freelist);</span><br><span class="line"><span class="comment">/* 3466 */</span>     c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line"><span class="comment">/* 3467 */</span>     local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="comment">/* 3468 */</span>     <span class="keyword">return</span> freelist;</span><br></pre></td></tr></table></figure>
到<code>deactivate_slab</code>处说明需要解冻当前缓存的 slab ，即将<code>kmem_cache_cpu-&gt;slab</code>从<code>kmem_cache_cpu</code>上移除。将<code>kmem_cache_cpu-&gt;slab</code>和<code>kmem_cache_cpu-&gt;freelist</code>置 0 ，更新<code>kmem_cache_cpu-&gt;tid</code>，然后调用<code>deactivate_slab()</code>，<code>deactivate_slab()</code>做了以下工作：</li>
</ul>
<ol>
<li>将<code>kmem_cache_cpu-&gt;freelist</code>移交给<code>slab-&gt;freelist</code></li>
<li>置 <code>slab-&gt;frozen</code> 为 0</li>
<li>将这个 slab 放入合适的 list<blockquote>
<p>关于上述第 3 点的进一步解释：根据 slab 的状态</p>
<ul>
<li>如果是 full slab 则不管</li>
<li>如果是 partial slab 就放入其所在 node 的<code>kmem_cache_node-&gt;partial</code></li>
<li>如果是 empty slab 则要看<code>kmem_cache_node-&gt;partial</code>上已有的 slab 数是否大于阈值<code>kmem_cache-&gt;min_partial</code>，如果大于就销毁这个 slab ，即将其还给 buddy system，否则还是放入<code>kmem_cache_node-&gt;partial</code></li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/mm/slub.c:3470</span></span><br><span class="line"><span class="comment">/* 3470 */</span> deactivate_slab:</span><br><span class="line"><span class="comment">/* 3471 */</span> </span><br><span class="line"><span class="comment">/* 3472 */</span>     local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="comment">/* 3473 */</span>     <span class="keyword">if</span> (slab != c-&gt;slab) &#123;</span><br><span class="line"><span class="comment">/* 3474 */</span>         local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="comment">/* 3475 */</span>         <span class="keyword">goto</span> reread_slab;</span><br><span class="line"><span class="comment">/* 3476 */</span>     &#125;</span><br><span class="line"><span class="comment">/* 3477 */</span>     freelist = c-&gt;freelist;</span><br><span class="line"><span class="comment">/* 3478 */</span>     c-&gt;slab = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* 3479 */</span>     c-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* 3480 */</span>     c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line"><span class="comment">/* 3481 */</span>     local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="comment">/* 3482 */</span>     deactivate_slab(s, slab, freelist);</span><br></pre></td></tr></table></figure>
走到<code>new_slab</code>处说明<code>kmem_cache_cpu</code>需要缓存一张新的 slab，首先遍历<code>kmem_cache_cpu-&gt;partial</code>，从上面取一张 slab</li>
</ol>
<ul>
<li>如果该 slab 的 node 不是指定的 node 或者该 slab 属于<code>pfmemalloc</code>池而<code>gfpflags</code>表明不允许从该区域分配内存，就用<code>__put_partials()</code>把这张 slab 放回其所属 node 的<code>kmem_cache_node-&gt;partial</code>上，同样如果这张 slab 为 empty 且<code>kmem_cache_node-&gt;partial</code>上 slab 数超过阈值就要销毁这张 slab</li>
<li>否则就冻结这张 slab 并跳转到<code>retry_load_slab</code>处准备缓存这张 slab 作为<code>kmem_cache_cpu-&gt;slab</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/mm/slub.c:3484</span></span><br><span class="line"><span class="comment">/* 3484 */</span> new_slab:</span><br><span class="line"><span class="comment">/* 3485 */</span> </span><br><span class="line"><span class="comment">/* 3486 */</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line"><span class="comment">/* 3487 */</span>     <span class="keyword">while</span> (slub_percpu_partial(c)) &#123;</span><br><span class="line"><span class="comment">/* 3488 */</span>         local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="comment">/* 3489 */</span>         <span class="keyword">if</span> (unlikely(c-&gt;slab)) &#123;</span><br><span class="line"><span class="comment">/* 3490 */</span>             local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="comment">/* 3491 */</span>             <span class="keyword">goto</span> reread_slab;</span><br><span class="line"><span class="comment">/* 3492 */</span>         &#125;</span><br><span class="line"><span class="comment">/* 3493 */</span>         <span class="keyword">if</span> (unlikely(!slub_percpu_partial(c))) &#123;</span><br><span class="line"><span class="comment">/* 3494 */</span>             local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="comment">/* 3495 */</span>             <span class="comment">/* we were preempted and partial list got empty */</span></span><br><span class="line"><span class="comment">/* 3496 */</span>             <span class="keyword">goto</span> new_objects;</span><br><span class="line"><span class="comment">/* 3497 */</span>         &#125;</span><br><span class="line"><span class="comment">/* 3498 */</span> </span><br><span class="line"><span class="comment">/* 3499 */</span>         slab = slub_percpu_partial(c);</span><br><span class="line"><span class="comment">/* 3500 */</span>         slub_set_percpu_partial(c, slab);</span><br><span class="line"><span class="comment">/* 3501 */</span>         local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="comment">/* 3502 */</span>         stat(s, CPU_PARTIAL_ALLOC);</span><br><span class="line"><span class="comment">/* 3503 */</span> </span><br><span class="line"><span class="comment">/* 3504 */</span>         <span class="keyword">if</span> (unlikely(!node_match(slab, node) ||</span><br><span class="line"><span class="comment">/* 3505 */</span>                 !pfmemalloc_match(slab, gfpflags))) &#123;</span><br><span class="line"><span class="comment">/* 3506 */</span>             slab-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* 3507 */</span>             __put_partials(s, slab);</span><br><span class="line"><span class="comment">/* 3508 */</span>             <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">/* 3509 */</span>         &#125;</span><br><span class="line"><span class="comment">/* 3510 */</span> </span><br><span class="line"><span class="comment">/* 3511 */</span>         freelist = freeze_slab(s, slab);</span><br><span class="line"><span class="comment">/* 3512 */</span>         <span class="keyword">goto</span> retry_load_slab;</span><br><span class="line"><span class="comment">/* 3513 */</span>     &#125;</span><br><span class="line"><span class="comment">/* 3514 */</span> <span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
如果<code>kmem_cache_cpu-&gt;partial</code>没有 slab ，则会走到<code>new_objects</code>处</li>
<li><code>get_partial()</code>会到别的 partial list 上取一些 slab 补充到<code>kmem_cache_cpu-&gt;partial</code>里：<ul>
<li>首先到本地 node 的<code>kmem_cache_node-&gt;partial</code>中取一张 slab ，然后将剩下的最多<code>kmem_cache-&gt;cpu_partial_slabs / 2</code>个 slab 放入<code>kmem_cache_cpu-&gt;partial</code></li>
<li>如果<code>kmem_cache_node-&gt;partial</code>也没有 slab ，分配的时候也没有指定 node ，就去别的 node 上取（从近到远）</li>
</ul>
</li>
<li>如果取到了 slab ，就冻结这张 slab 并跳转到<code>retry_load_slab</code>处准备缓存这张 slab 作为<code>kmem_cache_cpu-&gt;slab</code></li>
<li>否则 per-cpu 和 per-node 的 slab cache 都没有 slab 了，只能调用<code>new_slab()</code>，最后会用<code>alloc_pages_node()</code>向 buddy system 申请内存作为一张 slab ，如果还是失败只能返回 <code>NULL</code>，冻结这张 slab，然后向下走到<code>retry_load_slab</code>处准备缓存这张 slab 作为<code>kmem_cache_cpu-&gt;slab</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/mm/slub.c:3516</span></span><br><span class="line"><span class="comment">/* 3516 */</span> new_objects:</span><br><span class="line"><span class="comment">/* 3517 */</span> </span><br><span class="line"><span class="comment">/* 3518 */</span>     pc.flags = gfpflags;</span><br><span class="line"><span class="comment">/* 3519 */</span>     pc.orig_size = orig_size;</span><br><span class="line"><span class="comment">/* 3520 */</span>     slab = get_partial(s, node, &amp;pc);</span><br><span class="line"><span class="comment">/* 3521 */</span>     <span class="keyword">if</span> (slab) &#123;</span><br><span class="line"><span class="comment">/* 3522 */</span>         <span class="keyword">if</span> (kmem_cache_debug(s)) &#123;</span><br><span class="line"><span class="comment">/* 3523 */</span>             freelist = pc.object;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3529 */</span>             <span class="keyword">if</span> (s-&gt;flags &amp; SLAB_STORE_USER)</span><br><span class="line"><span class="comment">/* 3530 */</span>                 set_track(s, freelist, TRACK_ALLOC, addr);</span><br><span class="line"><span class="comment">/* 3531 */</span> </span><br><span class="line"><span class="comment">/* 3532 */</span>             <span class="keyword">return</span> freelist;</span><br><span class="line"><span class="comment">/* 3533 */</span>         &#125;</span><br><span class="line"><span class="comment">/* 3534 */</span> </span><br><span class="line"><span class="comment">/* 3535 */</span>         freelist = freeze_slab(s, slab);</span><br><span class="line"><span class="comment">/* 3536 */</span>         <span class="keyword">goto</span> retry_load_slab;</span><br><span class="line"><span class="comment">/* 3537 */</span>     &#125;</span><br><span class="line"><span class="comment">/* 3538 */</span> </span><br><span class="line"><span class="comment">/* 3539 */</span>     slub_put_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line"><span class="comment">/* 3540 */</span>     slab = new_slab(s, gfpflags, node);</span><br><span class="line"><span class="comment">/* 3541 */</span>     c = slub_get_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line"><span class="comment">/* 3542 */</span> </span><br><span class="line"><span class="comment">/* 3543 */</span>     <span class="keyword">if</span> (unlikely(!slab)) &#123;</span><br><span class="line"><span class="comment">/* 3544 */</span>         slab_out_of_memory(s, gfpflags, node);</span><br><span class="line"><span class="comment">/* 3545 */</span>         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* 3546 */</span>     &#125;</span><br><span class="line"><span class="comment">/* 3547 */</span> </span><br><span class="line"><span class="comment">/* 3548 */</span>     stat(s, ALLOC_SLAB);</span><br><span class="line"><span class="comment">/* 3549 */</span> </span><br><span class="line"><span class="comment">/* 3550 */</span>     <span class="keyword">if</span> (kmem_cache_debug(s)) &#123;</span><br><span class="line"><span class="comment">/* 3551 */</span>         freelist = alloc_single_from_new_slab(s, slab, orig_size);</span><br><span class="line"><span class="comment">/* 3552 */</span> </span><br><span class="line"><span class="comment">/* 3553 */</span>         <span class="keyword">if</span> (unlikely(!freelist))</span><br><span class="line"><span class="comment">/* 3554 */</span>             <span class="keyword">goto</span> new_objects;</span><br><span class="line"><span class="comment">/* 3555 */</span>      </span><br><span class="line"><span class="comment">/* 3556 */</span>         <span class="keyword">if</span> (s-&gt;flags &amp; SLAB_STORE_USER)</span><br><span class="line"><span class="comment">/* 3557 */</span>             set_track(s, freelist, TRACK_ALLOC, addr);</span><br><span class="line"><span class="comment">/* 3558 */</span>      </span><br><span class="line"><span class="comment">/* 3559 */</span>         <span class="keyword">return</span> freelist;</span><br><span class="line"><span class="comment">/* 3560 */</span>     &#125;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3566 */</span>     freelist = slab-&gt;freelist;</span><br><span class="line"><span class="comment">/* 3567 */</span>     slab-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* 3568 */</span>     slab-&gt;inuse = slab-&gt;objects;</span><br><span class="line"><span class="comment">/* 3569 */</span>     slab-&gt;frozen = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* 3570 */</span>      </span><br><span class="line"><span class="comment">/* 3571 */</span>     inc_slabs_node(s, slab_nid(slab), slab-&gt;objects);</span><br><span class="line"><span class="comment">/* 3572 */</span>      </span><br><span class="line"><span class="comment">/* 3573 */</span>     <span class="keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags))) &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3578 */</span>         deactivate_slab(s, slab, get_freepointer(s, freelist));</span><br><span class="line"><span class="comment">/* 3579 */</span>         <span class="keyword">return</span> freelist;</span><br><span class="line"><span class="comment">/* 3580 */</span>     &#125;</span><br></pre></td></tr></table></figure>
到<code>retry_load_slab</code>处，如果<code>kmem_cache_cpu</code>上本来缓存了 slab ，则要先调用<code>deactivate_slab()</code>将旧 slab 从<code>kmem_cache_cpu</code>上移除，令新 slab 作为<code>kmem_cache_cpu-&gt;slab</code>并跳转到 <code>load_freelist</code>取空闲 object<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/mm/slub.c:3582</span></span><br><span class="line"><span class="comment">/* 3582 */</span> retry_load_slab:</span><br><span class="line"><span class="comment">/* 3583 */</span>      </span><br><span class="line"><span class="comment">/* 3584 */</span>     local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="comment">/* 3585 */</span>     <span class="keyword">if</span> (unlikely(c-&gt;slab)) &#123;</span><br><span class="line"><span class="comment">/* 3586 */</span>         <span class="type">void</span> *flush_freelist = c-&gt;freelist;</span><br><span class="line"><span class="comment">/* 3587 */</span>         <span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">flush_slab</span> =</span> c-&gt;slab;</span><br><span class="line"><span class="comment">/* 3588 */</span>      </span><br><span class="line"><span class="comment">/* 3589 */</span>         c-&gt;slab = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* 3590 */</span>         c-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* 3591 */</span>         c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line"><span class="comment">/* 3592 */</span>      </span><br><span class="line"><span class="comment">/* 3593 */</span>         local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="comment">/* 3594 */</span>      </span><br><span class="line"><span class="comment">/* 3595 */</span>         deactivate_slab(s, flush_slab, flush_freelist);</span><br><span class="line"><span class="comment">/* 3596 */</span>      </span><br><span class="line"><span class="comment">/* 3597 */</span>         stat(s, CPUSLAB_FLUSH);</span><br><span class="line"><span class="comment">/* 3598 */</span>      </span><br><span class="line"><span class="comment">/* 3599 */</span>         <span class="keyword">goto</span> retry_load_slab;</span><br><span class="line"><span class="comment">/* 3600 */</span>     &#125;</span><br><span class="line"><span class="comment">/* 3601 */</span>     c-&gt;slab = slab;</span><br><span class="line"><span class="comment">/* 3602 */</span>      </span><br><span class="line"><span class="comment">/* 3603 */</span>     <span class="keyword">goto</span> load_freelist;</span><br><span class="line"><span class="comment">/* 3604 */</span> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="全流程"><a href="#全流程" class="headerlink" title="全流程"></a>全流程</h3><p>总结一下 slab allocator 中对象分配的全流程：  </p>
<img src="/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/slab_alloc.jpg" class title="test">

<h2 id="Free-an-object"><a href="#Free-an-object" class="headerlink" title="Free an object"></a>Free an object</h2><h3 id="上层-API-1"><a href="#上层-API-1" class="headerlink" title="上层 API"></a>上层 API</h3><ul>
<li><code>kfree()</code>用于释放任意对象</li>
<li><code>kmem_cache_free()</code>用于释放指定 slab cache 里的对象</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/mm/slub.c:4389</span></span><br><span class="line"><span class="comment">/* 4389 */</span> <span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *object)</span></span><br><span class="line"><span class="comment">/* 4390 */</span> &#123;</span><br><span class="line"><span class="comment">/* 4391 */</span>     <span class="class"><span class="keyword">struct</span> <span class="title">folio</span> *<span class="title">folio</span>;</span></span><br><span class="line"><span class="comment">/* 4392 */</span>     <span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line"><span class="comment">/* 4393 */</span>     <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span>;</span></span><br><span class="line"><span class="comment">/* 4394 */</span>     <span class="type">void</span> *x = (<span class="type">void</span> *)object;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 4398 */</span>     <span class="keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(object)))</span><br><span class="line"><span class="comment">/* 4399 */</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">/* 4400 */</span> </span><br><span class="line"><span class="comment">/* 4401 */</span>     folio = virt_to_folio(object);</span><br><span class="line"><span class="comment">/* 4402 */</span>     <span class="keyword">if</span> (unlikely(!folio_test_slab(folio))) &#123;</span><br><span class="line"><span class="comment">/* 4403 */</span>         free_large_kmalloc(folio, (<span class="type">void</span> *)object);</span><br><span class="line"><span class="comment">/* 4404 */</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">/* 4405 */</span>     &#125;</span><br><span class="line"><span class="comment">/* 4406 */</span> </span><br><span class="line"><span class="comment">/* 4407 */</span>     slab = folio_slab(folio);</span><br><span class="line"><span class="comment">/* 4408 */</span>     s = slab-&gt;slab_cache;</span><br><span class="line"><span class="comment">/* 4409 */</span>     slab_free(s, slab, x, _RET_IP_);</span><br><span class="line"><span class="comment">/* 4410 */</span> &#125;</span><br></pre></td></tr></table></figure>
<p><code>kree()</code>里如果 slab 所在页没有设置<code>PG_slab</code>这个 flag ，说明当时分配的时候是直接用的 page allocator，需要调用<code>free_large_kmalloc()</code>，然后调用<code>folio_put()</code>交给 page allocator</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/mm/slub.c:4367</span></span><br><span class="line"><span class="comment">/* 4367 */</span> <span class="type">static</span> <span class="type">void</span> <span class="title function_">free_large_kmalloc</span><span class="params">(<span class="keyword">struct</span> folio *folio, <span class="type">void</span> *object)</span></span><br><span class="line"><span class="comment">/* 4368 */</span> &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 4380 */</span>     folio_put(folio);</span><br><span class="line"><span class="comment">/* 4381 */</span> &#125;</span><br></pre></td></tr></table></figure>
<p><br><code>kmem_cache_free()</code>用<code>cache_from_obj()</code>检查要释放的对象是不是真的来自指定的 <code>kmem_cache</code>，如果不是的话就直接返回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/mm/slub.c:4357</span></span><br><span class="line"><span class="comment">/* 4357 */</span> <span class="type">void</span> <span class="title function_">kmem_cache_free</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">void</span> *x)</span></span><br><span class="line"><span class="comment">/* 4358 */</span> &#123;</span><br><span class="line"><span class="comment">/* 4359 */</span>     s = cache_from_obj(s, x);</span><br><span class="line"><span class="comment">/* 4360 */</span>     <span class="keyword">if</span> (!s)</span><br><span class="line"><span class="comment">/* 4361 */</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">/* 4362 */</span>     trace_kmem_cache_free(_RET_IP_, x, s);</span><br><span class="line"><span class="comment">/* 4363 */</span>     slab_free(s, virt_to_slab(x), x, _RET_IP_);</span><br><span class="line"><span class="comment">/* 4364 */</span> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="slab-allocator-层-1"><a href="#slab-allocator-层-1" class="headerlink" title="slab allocator 层"></a>slab allocator 层</h3><p><code>kfree()</code>和<code>kmem_cache_free()</code>都会调用到<code>slab_free()</code>进而到<code>do_slab_free()</code></p>
<blockquote>
<p>这里也有一个 memcg 相关的处理</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/mm/slub.c:4293</span></span><br><span class="line"><span class="comment">/* 4293 */</span> <span class="type">static</span> __fastpath_inline</span><br><span class="line"><span class="comment">/* 4294 */</span> <span class="type">void</span> <span class="title function_">slab_free</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> slab *slab, <span class="type">void</span> *object,</span></span><br><span class="line"><span class="params"><span class="comment">/* 4295 */</span>         <span class="type">unsigned</span> <span class="type">long</span> addr)</span></span><br><span class="line"><span class="comment">/* 4296 */</span> &#123;</span><br><span class="line"><span class="comment">/* 4297 */</span>     memcg_slab_free_hook(s, slab, &amp;object, <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 4298 */</span></span><br><span class="line"><span class="comment">/* 4299 */</span>     <span class="keyword">if</span> (likely(slab_free_hook(s, object, slab_want_init_on_free(s))))</span><br><span class="line"><span class="comment">/* 4301 */</span>         do_slab_free(s, slab, object, object, <span class="number">1</span>, addr);</span><br><span class="line"><span class="comment">/* 4302 */</span> &#125;</span><br></pre></td></tr></table></figure>
<p><br>在 <code>do_slab_free()</code>中首先看 <code>kmem_cache_cpu-&gt;slab</code>，如果就是要释放的 object 所在 slab，直接将 object 放入<code>kmem_cache_cpu-&gt;freelist</code>就 ok（按 LIFO 顺序），否则就走 slowpath ：<code>__slab_free()</code></p>
<blockquote>
<p>一般来说会走无锁的 fastpath ，但如果配置了<code>CONFIG_PREEMPT_RT</code>即实时内核，则需要加锁，然而这两条分支把 object 放回 slab 的逻辑都是一样的：使 <code>kmem_cache_cpu-&gt;freelist</code> 指向释放的 object ，使释放 object 的 FP 指向原来的 <code>kmem_cache_cpu-&gt;freelist</code>，更新<code>kmem_cache_cpu-&gt;tid</code> 。此外，还需要检测前后<code>kmem_cache_cpu-&gt;slab</code>是否一致，如果不一致说明发生过抢占就跳回<code>redo</code>重来</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/mm/slub.c:4230</span></span><br><span class="line"><span class="comment">/* 4230 */</span> <span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">do_slab_free</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s,</span></span><br><span class="line"><span class="params"><span class="comment">/* 4231 */</span>                 <span class="keyword">struct</span> slab *slab, <span class="type">void</span> *head, <span class="type">void</span> *tail,</span></span><br><span class="line"><span class="params"><span class="comment">/* 4232 */</span>                 <span class="type">int</span> cnt, <span class="type">unsigned</span> <span class="type">long</span> addr)</span></span><br><span class="line"><span class="comment">/* 4233 */</span> &#123;</span><br><span class="line"><span class="comment">/* 4234 */</span>     <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span>;</span></span><br><span class="line"><span class="comment">/* 4235 */</span>     <span class="type">unsigned</span> <span class="type">long</span> tid;</span><br><span class="line"><span class="comment">/* 4236 */</span>     <span class="type">void</span> **freelist;</span><br><span class="line"><span class="comment">/* 4237 */</span> </span><br><span class="line"><span class="comment">/* 4238 */</span> redo:</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 4245 */</span>     c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line"><span class="comment">/* 4246 */</span>     tid = READ_ONCE(c-&gt;tid);</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 4249 */</span>     barrier();</span><br><span class="line"><span class="comment">/* 4250 */</span> </span><br><span class="line"><span class="comment">/* 4251 */</span>     <span class="keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;</span><br><span class="line"><span class="comment">/* 4252 */</span>         __slab_free(s, slab, head, tail, cnt, addr);</span><br><span class="line"><span class="comment">/* 4253 */</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">/* 4254 */</span>     &#125;</span><br><span class="line"><span class="comment">/* 4255 */</span> </span><br><span class="line"><span class="comment">/* 4256 */</span>     <span class="keyword">if</span> (USE_LOCKLESS_FAST_PATH()) &#123;</span><br><span class="line"><span class="comment">/* 4257 */</span>         freelist = READ_ONCE(c-&gt;freelist);</span><br><span class="line"><span class="comment">/* 4258 */</span> </span><br><span class="line"><span class="comment">/* 4259 */</span>         set_freepointer(s, tail, freelist);</span><br><span class="line"><span class="comment">/* 4260 */</span> </span><br><span class="line"><span class="comment">/* 4261 */</span>         <span class="keyword">if</span> (unlikely(!__update_cpu_freelist_fast(s, freelist, head, tid))) &#123;</span><br><span class="line"><span class="comment">/* 4262 */</span>             note_cmpxchg_failure(<span class="string">&quot;slab_free&quot;</span>, s, tid);</span><br><span class="line"><span class="comment">/* 4263 */</span>             <span class="keyword">goto</span> redo;</span><br><span class="line"><span class="comment">/* 4264 */</span>         &#125;</span><br><span class="line"><span class="comment">/* 4265 */</span>     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* 4266 */</span>         <span class="comment">/* Update the free list under the local lock */</span></span><br><span class="line"><span class="comment">/* 4267 */</span>         local_lock(&amp;s-&gt;cpu_slab-&gt;lock);</span><br><span class="line"><span class="comment">/* 4268 */</span>         c = this_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line"><span class="comment">/* 4269 */</span>         <span class="keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;</span><br><span class="line"><span class="comment">/* 4270 */</span>             local_unlock(&amp;s-&gt;cpu_slab-&gt;lock);</span><br><span class="line"><span class="comment">/* 4271 */</span>             <span class="keyword">goto</span> redo;</span><br><span class="line"><span class="comment">/* 4272 */</span>         &#125;</span><br><span class="line"><span class="comment">/* 4273 */</span>         tid = c-&gt;tid;</span><br><span class="line"><span class="comment">/* 4274 */</span>         freelist = c-&gt;freelist;</span><br><span class="line"><span class="comment">/* 4275 */</span> </span><br><span class="line"><span class="comment">/* 4276 */</span>         set_freepointer(s, tail, freelist);</span><br><span class="line"><span class="comment">/* 4277 */</span>         c-&gt;freelist = head;</span><br><span class="line"><span class="comment">/* 4278 */</span>         c-&gt;tid = next_tid(tid);</span><br><span class="line"><span class="comment">/* 4279 */</span> </span><br><span class="line"><span class="comment">/* 4280 */</span>         local_unlock(&amp;s-&gt;cpu_slab-&gt;lock);</span><br><span class="line"><span class="comment">/* 4281 */</span>     &#125;</span><br><span class="line"><span class="comment">/* 4282 */</span>     stat_add(s, FREE_FASTPATH, cnt);</span><br><span class="line"><span class="comment">/* 4283 */</span> &#125;</span><br></pre></td></tr></table></figure>
<p><br>如果释放的 object 不在<code>kmem_cache_cpu-&gt;slab</code>上，就要到<code>__slab_free()</code>里处理两件事：</p>
<ol>
<li>将 object 放到合适的 freelist 中</li>
<li>如果 object 所在的 slab 的状态因 object 的释放而发生了改变（例如由 full 变为 partial），可能需要将这张 slab 移到合适的 list 上<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/mm/slub.c:4098</span></span><br><span class="line"><span class="comment">/* 4098 */</span> <span class="type">static</span> <span class="type">void</span> __slab_free(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> slab *slab,</span><br><span class="line"><span class="comment">/* 4099 */</span>          <span class="type">void</span> *head, <span class="type">void</span> *tail, <span class="type">int</span> cnt,</span><br><span class="line"><span class="comment">/* 4100 */</span>          <span class="type">unsigned</span> <span class="type">long</span> addr)</span><br><span class="line"><span class="comment">/* 4101 */</span> </span><br><span class="line"><span class="comment">/* 4102 */</span> &#123;</span><br><span class="line"><span class="comment">/* 4103 */</span>     <span class="type">void</span> *prior;</span><br><span class="line"><span class="comment">/* 4104 */</span>     <span class="type">int</span> was_frozen;</span><br><span class="line"><span class="comment">/* 4105 */</span>     <span class="class"><span class="keyword">struct</span> <span class="title">slab</span> <span class="title">new</span>;</span></span><br><span class="line"><span class="comment">/* 4106 */</span>     <span class="type">unsigned</span> <span class="type">long</span> counters;</span><br><span class="line"><span class="comment">/* 4107 */</span>     <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">n</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* 4108 */</span>     <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="comment">/* 4109 */</span>     <span class="type">bool</span> on_node_partial;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>首先先把 object 放回 slab 里，用 do-while 循环保证<code>slab_update_freelist()</code>成功更新 slab 的 freelist 和 counter （可能由于并发问题更新失败）  </p>
<p>与第4131行分支相关的几个条件：</p>
<ul>
<li><code>new.inuse -= cnt</code>后<code>!new.inuse</code>的话说明这张 slab 由于 object 的释放将会变成 empty slab</li>
<li><code>!prior</code>即<code>slab-&gt;freelist == null</code>，说明这张 slab 是 full slab ，由于 object 的释放将会变成 partial slab</li>
<li><code>!was_frozen</code>说明这张 slab 不是<code>kmem_cache_cpu-&gt;slab</code></li>
<li><code>kmem_cache_has_cpu_partial()</code>判断有没有配置<code>CONFIG_SLUB_CPU_PARTIAL</code>，即<code>kmem_cache_cpu</code>有没有 partial list</li>
</ul>
<p>要进入分支，首先 slab 不能是 <code>kmem_cache_cpu-&gt;slab</code>，有以下两种可能：</p>
<ol>
<li><code>kmem_cache_cpu</code>没有 partial list ，slab 原来是 full 或者即将变为 empty</li>
<li><code>kmem_cache_cpu</code>有 partial list ，slab 原来是 partial 即将变为 empty</li>
</ol>
<p>进入分支说明可能需要移动这张 slab 到<code>kmem_cache_node-&gt;partial</code>上或者从<code>kmem_cache_node-&gt;partial</code>上移出来，不管怎样先获取 slab 所在 node 和 list 锁以及判断 slab 是不是在该 node 的<code>kmem_cache_node-&gt;partial</code>上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/mm/slub.c:4118</span></span><br><span class="line"><span class="comment">/* 4118 */</span>     <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">/* 4119 */</span>         <span class="keyword">if</span> (unlikely(n)) &#123;</span><br><span class="line"><span class="comment">/* 4120 */</span>             spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line"><span class="comment">/* 4121 */</span>             n = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* 4122 */</span>         &#125;</span><br><span class="line"><span class="comment">/* 4123 */</span>         prior = slab-&gt;freelist;</span><br><span class="line"><span class="comment">/* 4124 */</span>         counters = slab-&gt;counters;</span><br><span class="line"><span class="comment">/* 4125 */</span>         set_freepointer(s, tail, prior);</span><br><span class="line"><span class="comment">/* 4126 */</span>         new.counters = counters;</span><br><span class="line"><span class="comment">/* 4127 */</span>         was_frozen = new.frozen;</span><br><span class="line"><span class="comment">/* 4128 */</span>         new.inuse -= cnt;</span><br><span class="line"><span class="comment">/* 4129 */</span>         <span class="keyword">if</span> ((!new.inuse || !prior) &amp;&amp; !was_frozen) &#123;</span><br><span class="line"><span class="comment">/* 4130 */</span>             <span class="comment">/* Needs to be taken off a list */</span></span><br><span class="line"><span class="comment">/* 4131 */</span>             <span class="keyword">if</span> (!kmem_cache_has_cpu_partial(s) || prior) &#123;</span><br><span class="line"><span class="comment">/* 4132 */</span> </span><br><span class="line"><span class="comment">/* 4133 */</span>                 n = get_node(s, slab_nid(slab));</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 4142 */</span>                 spin_lock_irqsave(&amp;n-&gt;list_lock, flags);</span><br><span class="line"><span class="comment">/* 4143 */</span> </span><br><span class="line"><span class="comment">/* 4144 */</span>                 on_node_partial = slab_test_node_partial(slab);</span><br><span class="line"><span class="comment">/* 4145 */</span>             &#125;</span><br><span class="line"><span class="comment">/* 4146 */</span>         &#125;</span><br><span class="line"><span class="comment">/* 4147 */</span> </span><br><span class="line"><span class="comment">/* 4148 */</span>     &#125; <span class="keyword">while</span> (!slab_update_freelist(s, slab,</span><br><span class="line"><span class="comment">/* 4149 */</span>         prior, counters,</span><br><span class="line"><span class="comment">/* 4150 */</span>         head, new.counters,</span><br><span class="line"><span class="comment">/* 4151 */</span>         <span class="string">&quot;__slab_free&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>如果<code>!n</code>，对应没有进入第4131行的情况，说明 slab 无需移动到<code>kmem_cache_node</code>的 list 上或从中移出，而且：</p>
<ul>
<li>如果这张 slab 由 full slab 变为了 partial slab ，且<code>kmem_cache_cpu</code>有 partial list，则用<code>put_cpu_partial()</code>把其放入<code>kmem_cache_cpu-&gt;partial</code>，但如果此时<code>kmem_cache_cpu-&gt;partial</code>上 slab 的数量超过了阈值 <code>kmem_cache-&gt;cpu_partial_slabs</code>，就会将整条<code>kmem_cache_cpu-&gt;partial</code>都移到<code>kmem_cache_node-&gt;partial</code>上</li>
<li>否则 slab 无需移动，则直接返回<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/mm/slub.c:4153</span></span><br><span class="line"><span class="comment">/* 4153 */</span>     <span class="keyword">if</span> (likely(!n)) &#123;</span><br><span class="line"><span class="comment">/* 4154 */</span> </span><br><span class="line"><span class="comment">/* 4155 */</span>         <span class="keyword">if</span> (likely(was_frozen)) &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 4160 */</span>             stat(s, FREE_FROZEN);</span><br><span class="line"><span class="comment">/* 4161 */</span>         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (kmem_cache_has_cpu_partial(s) &amp;&amp; !prior) &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 4166 */</span>             put_cpu_partial(s, slab, <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 4167 */</span>             stat(s, CPU_PARTIAL_FREE);</span><br><span class="line"><span class="comment">/* 4168 */</span>         &#125;</span><br><span class="line"><span class="comment">/* 4169 */</span> </span><br><span class="line"><span class="comment">/* 4170 */</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">/* 4171 */</span>     &#125;</span><br></pre></td></tr></table></figure>
这张 slab 原本不在 <code>kmem_cache_node-&gt;partial</code> 上（有可能在<code>kmem_cache_cpu-&gt;partial</code>上或者是 full slab），也不是由 full slab 变为 partial slab 的情况，则说明它在<code>kmem_cache_cpu-&gt;partial</code>上，无需移动这张 slab ，开锁后返回<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/mm/slub.c:4177</span></span><br><span class="line"><span class="comment">/* 4177 */</span>     <span class="keyword">if</span> (prior &amp;&amp; !on_node_partial) &#123;</span><br><span class="line"><span class="comment">/* 4178 */</span>         spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line"><span class="comment">/* 4179 */</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">/* 4180 */</span>     &#125;</span><br></pre></td></tr></table></figure>
如果这张在<code>kmem_cache_node-&gt;partial</code>上的 slab 变为 empty 且 <code>kmem_cache_node-&gt;partial</code>上 slab 的数量超过阈值<code>kmem_cache-&gt;min_partial</code>，就到<code>slab_empty</code>处销毁这张 slab<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/mm/slub.c:4182</span></span><br><span class="line"><span class="comment">/* 4182 */</span>     <span class="keyword">if</span> (unlikely(!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial))</span><br><span class="line"><span class="comment">/* 4183 */</span>         <span class="keyword">goto</span> slab_empty;</span><br></pre></td></tr></table></figure>
如果<code>kmem_cache_cpu</code>没有 partial list（这种情况一般是配置了<code>CONFIG_SLUB_DEBUG</code>，于是也会启用<code>kmem_cache_node</code>的 full list）且 slab 由 full slab 变为 partial slab，就将这张 slab 从<code>kmem_cache_node-&gt;full</code>上移除，移到<code>kmem_cache_node-&gt;partial</code>上<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/mm/slub.c:4189</span></span><br><span class="line"><span class="comment">/* 4189 */</span>     <span class="keyword">if</span> (!kmem_cache_has_cpu_partial(s) &amp;&amp; unlikely(!prior)) &#123;</span><br><span class="line"><span class="comment">/* 4190 */</span>         remove_full(s, n, slab);</span><br><span class="line"><span class="comment">/* 4191 */</span>         add_partial(n, slab, DEACTIVATE_TO_TAIL);</span><br><span class="line"><span class="comment">/* 4192 */</span>         stat(s, FREE_ADD_PARTIAL);</span><br><span class="line"><span class="comment">/* 4193 */</span>     &#125;</span><br><span class="line"><span class="comment">/* 4194 */</span>     spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line"><span class="comment">/* 4195 */</span>     <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<code>slab_empty</code>处理把 empty slab 还给 buddy system 的场景<br>首先将 slab 从原所在的 list 上移除（<code>kmem_cache_node-&gt;partial</code>或<code>kmem_cache_node-&gt;full</code>），然后调用<code>discard_slab()</code>最后调用<code>__free_pages()</code>释放回 buddy system<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-6.8.7/mm/slub.c:4197</span></span><br><span class="line"><span class="comment">/* 4197 */</span> slab_empty:</span><br><span class="line"><span class="comment">/* 4198 */</span>     <span class="keyword">if</span> (prior) &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 4202 */</span>         remove_partial(n, slab);</span><br><span class="line"><span class="comment">/* 4203 */</span>         stat(s, FREE_REMOVE_PARTIAL);</span><br><span class="line"><span class="comment">/* 4204 */</span>     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* 4205 */</span>         <span class="comment">/* Slab must be on the full list */</span></span><br><span class="line"><span class="comment">/* 4206 */</span>         remove_full(s, n, slab);</span><br><span class="line"><span class="comment">/* 4207 */</span>     &#125;</span><br><span class="line"><span class="comment">/* 4208 */</span> </span><br><span class="line"><span class="comment">/* 4209 */</span>     spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line"><span class="comment">/* 4210 */</span>     stat(s, FREE_SLAB);</span><br><span class="line"><span class="comment">/* 4211 */</span>     discard_slab(s, slab);</span><br><span class="line"><span class="comment">/* 4212 */</span> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="全流程-1"><a href="#全流程-1" class="headerlink" title="全流程"></a>全流程</h3><p>总结一下 slab allocator 中对象释放的全流程：  </p>
<img src="/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/slab_free.jpg" class title="test">
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="https://github.com/slavin-ayu">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Overview"><span class="toc-number">1.</span> <span class="toc-text">Overview</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#object-slab-layout"><span class="toc-number">1.1.</span> <span class="toc-text">object &amp; slab layout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kmem-cache"><span class="toc-number">1.2.</span> <span class="toc-text">kmem_cache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-slab"><span class="toc-number">1.3.</span> <span class="toc-text">struct slab</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slab-cache-layout"><span class="toc-number">1.4.</span> <span class="toc-text">slab cache layout</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Allocate-an-object"><span class="toc-number">2.</span> <span class="toc-text">Allocate an object</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E5%B1%82-API"><span class="toc-number">2.1.</span> <span class="toc-text">上层 API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#kmem-cache-alloc-%E7%B3%BB%E5%88%97"><span class="toc-number">2.1.1.</span> <span class="toc-text">kmem_cache_alloc() 系列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kmalloc-%E7%B3%BB%E5%88%97"><span class="toc-number">2.1.2.</span> <span class="toc-text">kmalloc() 系列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slab-allocator-%E5%B1%82"><span class="toc-number">2.2.</span> <span class="toc-text">slab allocator 层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#slab-alloc-node"><span class="toc-number">2.2.1.</span> <span class="toc-text">slab_alloc_node()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#slab-alloc-node-%EF%BC%9Afastpath"><span class="toc-number">2.2.2.</span> <span class="toc-text">__slab_alloc_node()：fastpath</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#slab-alloc-%EF%BC%9Aslowpath"><span class="toc-number">2.2.3.</span> <span class="toc-text">___slab_alloc()：slowpath</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">全流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Free-an-object"><span class="toc-number">3.</span> <span class="toc-text">Free an object</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E5%B1%82-API-1"><span class="toc-number">3.1.</span> <span class="toc-text">上层 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slab-allocator-%E5%B1%82-1"><span class="toc-number">3.2.</span> <span class="toc-text">slab allocator 层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%B5%81%E7%A8%8B-1"><span class="toc-number">3.3.</span> <span class="toc-text">全流程</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/&text=Slub allocator 分析"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/&title=Slub allocator 分析"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/&is_video=false&description=Slub allocator 分析"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Slub allocator 分析&body=Check out this article: https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/&title=Slub allocator 分析"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/&title=Slub allocator 分析"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/&title=Slub allocator 分析"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/&title=Slub allocator 分析"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/&name=Slub allocator 分析&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://slavin.cn/2024/05/06/Slub-allocator-%E5%88%86%E6%9E%90/&t=Slub allocator 分析"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2024
    Slavin
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/slavin-ayu">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
